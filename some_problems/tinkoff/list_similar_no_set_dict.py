"""

Для маркетплейсов важно уметь подбирать релевантные товары для выдачи на странице рекомендаций. Одним из подходов является поиск похожих клиентов. Если два клиента часто покупают товары из одинаковых категорий, то, скорее всего, один из них заинтересуется купленными товарами второго.

У вас есть два массива с номерами категорий товаров в порядке возрастания, которые были когда-либо куплены двумя клиентами. Будем считать эти два массива похожими, если они состоят из одних и тех же элементов (без учета кратности). Например, массивы ﻿
[
�
,
�
,
�
,
�
]
[A,B,C,C]﻿ и ﻿
[
�
,
�
,
�
,
�
]
[A,A,B,C]﻿ похожи, а массивы ﻿
[
�
,
�
,
�
]
[A,B,C]﻿ и ﻿
[
�
,
�
,
�
]
[A,B,D]﻿ – нет.

Напишите программу, которая определяет похожи ли два массива товаров или нет.

Формат входных данных
В первой строке содержится сортированная последовательность целых чисел, разделенных пробелом, которая задает первый массив. Аналогично во второй строке задается второй массив. Размеры массивов не превосходят 100000.

Формат выходных данных
Программа должна вывести слово «YES» (без кавычек), если клиенты похожи, и слово «NO» (без кавычек) в противном случае.
"""

ls_1 = input().split()
ls_2 = input().split()

last_index_1 = -1
last_index_2 = -1
ans = 'YES'

while ans != 'NO' and last_index_1 != len(ls_1) - 1:
    if ls_1[last_index_1 + 1] != ls_2[last_index_2 + 1]:
        ans = 'NO'
    else:
        for i in range(last_index_1 + 1, len(ls_1)):
            if ls_1[i] == ls_2[last_index_2 + 1]:
                next_last_i = i
            else:
                break
        for j in range(last_index_2 + 1, len(ls_2)):
            if ls_2[j] == ls_1[last_index_1 + 1]:
                next_last_j = j
            else:
                break

        last_index_1 = next_last_i
        last_index_2 = next_last_j
        if (last_index_1 == len(ls_1) - 1 and last_index_2 != len(ls_2) - 1) or (last_index_2 == len(ls_2) - 1 and last_index_1 != len(ls_1) - 1):
            ans = 'NO'

print(ans)